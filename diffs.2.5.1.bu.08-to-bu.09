diff -rc irc2.5.1.bu.08/Makefile irc2.5.1.bu.09/Makefile
*** irc2.5.1.bu.08/Makefile	Mon Oct 22 11:32:55 1990
--- irc2.5.1.bu.09/Makefile	Wed Nov  7 00:25:33 1990
***************
*** 26,34 ****
  # uncomment the following if you are using SunOS and NIS or YP
  # IRCDLIBS = -lresolv
  IRCDLIBS =
! # we use 4750, most people use 4711
! IRCDMODE = 4750
! # IRCDMODE = 4711
  
  MAKE = make 'CFLAGS=${CFLAGS}' 'CC=${CC}' 'IRCDLIBS=${IRCDLIBS}' 'IRCDMODE = ${IRCDMODE}'
  SUBDIRS=include common ircd
--- 26,34 ----
  # uncomment the following if you are using SunOS and NIS or YP
  # IRCDLIBS = -lresolv
  IRCDLIBS =
! # we use 4750 (best for group irc & CMDLINE_CONFIG), most people use 4711
! # IRCDMODE = 4750
! IRCDMODE = 4711
  
  MAKE = make 'CFLAGS=${CFLAGS}' 'CC=${CC}' 'IRCDLIBS=${IRCDLIBS}' 'IRCDMODE = ${IRCDMODE}'
  SUBDIRS=include common ircd
Common subdirectories: irc2.5.1.bu.08/common and irc2.5.1.bu.09/common
Common subdirectories: irc2.5.1.bu.08/doc and irc2.5.1.bu.09/doc
Common subdirectories: irc2.5.1.bu.08/include and irc2.5.1.bu.09/include
Common subdirectories: irc2.5.1.bu.08/irc and irc2.5.1.bu.09/irc
Only in irc2.5.1.bu.08: ircII1.95
Only in irc2.5.1.bu.09: ircII1.96
Common subdirectories: irc2.5.1.bu.08/ircd and irc2.5.1.bu.09/ircd
Common subdirectories: irc2.5.1.bu.08/vms and irc2.5.1.bu.09/vms
diff -rc irc2.5.1.bu.08/doc/ChangeLog irc2.5.1.bu.09/doc/ChangeLog
*** irc2.5.1.bu.08/doc/ChangeLog	Mon Oct 22 11:45:49 1990
--- irc2.5.1.bu.09/doc/ChangeLog	Wed Oct 31 15:39:26 1990
***************
*** 1,3 ****
--- 1,9 ----
+ Wed Oct 31 15:34:44 1990  Tom Hopkins  (hoppie@buengf.bu.edu)
+ 
+ 	* example.conf
+ 	  added an example of a restrict line, along with some brief
+ 	  explanation of how to use it.
+ 
  Sat Oct 20 17:12:53 1990  Helen Trillian Rose  (hrose at bucsd)
  
  	* Operator Etiquette 
diff -rc irc2.5.1.bu.08/doc/example.conf irc2.5.1.bu.09/doc/example.conf
*** irc2.5.1.bu.08/doc/example.conf	Wed Oct 24 00:39:28 1990
--- irc2.5.1.bu.09/doc/example.conf	Wed Nov  7 00:19:38 1990
***************
*** 16,27 ****
  #*   along with this program; if not, write to the Free Software
  #*   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  #*/
! # -- Jto -- 03 Jun 1990
! # Added some Kill line documentation
  #
  # -- htr -- 05 Oct 1990
  # Added Quarantine line documentation
  #
  # IRC example configuration file
  #
  # This file describes the information that should be present in your IRC
--- 16,30 ----
  #*   along with this program; if not, write to the Free Software
  #*   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  #*/
! # -- tih -- 04 Nov 1990
! # Added Restrict line documentation
  #
  # -- htr -- 05 Oct 1990
  # Added Quarantine line documentation
  #
+ # -- Jto -- 03 Jun 1990
+ # Added some Kill line documentation
+ #
  # IRC example configuration file
  #
  # This file describes the information that should be present in your IRC
***************
*** 105,110 ****
--- 108,130 ----
  # All users on tuminfo3 cannot connect to server during
  # 9 am and 12 am, and 2 pm till 5 pm.
  # K:tuminfo3.informatik.tu-muenchen.de:0900-1200,1400-1700:*
+ #
+ # Restrict lines
+ #
+ # An extended form of K line.  These look for a match and run an outside
+ # program to whose reply determines whether the person should be let on.
+ # R:<host>:program:username
+ # It is a good idea to use a full path name for the program.  Depending on
+ # the system, it might follow the instigator's path or accept ~ and such, 
+ # but there are no guarantees.
+ # The output of the program should be of the form
+ # 'Y <message>' to let the user in, or 
+ # 'N <message>' to keep them out.  In the case of 'N' the message is sent 
+ # as an error message to the user.  In the case of 'Y' it is ignored.
+ #
+ # The following example means hrose@cs.bu.edu can only get in if the
+ # program /other/irc/bin/arbitrary does not return an 'N'.
+ R:cs.bu.edu:/other/irc/bin/arbitrary:hrose
  #
  # Quarantine lines. These lines disallow connections to the 
  # specified server and drops the link to anyone connecting to them.
Only in irc2.5.1.bu.09/doc: example.conf~
diff -rc irc2.5.1.bu.08/include/ChangeLog irc2.5.1.bu.09/include/ChangeLog
*** irc2.5.1.bu.08/include/ChangeLog	Mon Oct 22 11:32:36 1990
--- irc2.5.1.bu.09/include/ChangeLog	Wed Oct 31 14:16:20 1990
***************
*** 17,22 ****
--- 17,39 ----
   *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ Tue Oct 30 14:10:00 1990  Thomas Hopkins (hoppie@buengf.bu.edu)
+ 
+ 	* config.h
+ 	R_LINES
+ 	* struct.h
+ 	Added support for R lines
+ 
+ Fri Oct 12 18:12:22 1990  Thomas Hopkins (hoppie@buengf.bu.edu)
+ 
+ 	* config.h
+ 	WALLOPS_REMOTE and WALLOPS_QUARANTINE
+ 	support for user logging (logfile specification)
+ 	* msg.h
+ 	added a parameter to MSG_LIST (enable list channel)
+ 	* struct.h
+ 	Added support for Q lines
+ 
  Wed Jun 20 11:44:00 1990  Jarkko Oikarinen (jto@tolsun.oulu.fi)
  
  	* config.h
diff -rc irc2.5.1.bu.08/include/config.h irc2.5.1.bu.09/include/config.h
*** irc2.5.1.bu.08/include/config.h	Tue Oct 23 22:19:24 1990
--- irc2.5.1.bu.09/include/config.h	Mon Nov  5 21:18:44 1990
***************
*** 18,23 ****
--- 18,29 ----
   */
  
  /* 
+  * --Hoppie -- 30 Oct 1990 
+  * Added support for restrict lines. (R_LINES)
+  * 
+  * --Hoppie -- 12 Oct 1990
+  * Added WALLOPS_REMOTE and WALLOPS_QUARANTINE, and stealth's user logging.
+  *
   * -- Jto -- 14 Jul 1990
   * Added Wumpus's MAXIMUM_LINKS fix
   *
***************
*** 144,149 ****
--- 150,177 ----
  #define WALLOPS_QUARANTINE /* Notify all opers of closing */
                                /* undesirable links */
  
+ /* R_LINES:  The conf file now allows the existence of R lines, or 
+    restrict lines.  These allow more freedom in the ability to restrict 
+    who is to sign on and when.  What the R line does is call an outside 
+    program which returns a reply indicating whether to let the person on.
+    Because there is another program involved, Delays and overhead could result.
+    It is for this reason that there is a line in config.h to decide whether 
+    it is something you want or need. -Hoppie */
+ 
+ /* #define R_LINES /* */
+ 
+ #ifdef R_LINES
+ /* Also, even if you have R lines defined, you might not want them to be 
+    checked everywhere, since it could cost lots of time and delay.  Therefore, 
+    The following two options are also offered:  R_LINES_REHASH rechecks for 
+    R lines after a rehash, and R_LINES_OFTEN, which rechecks it as often
+    as it does K lines.  Note that R_LINES_OFTEN is *very* likely to cause 
+    a resource drain, use at your own risk.  R_LINES_REHASH shouldn't be too
+    bad, assuming the programs are fairly short. */
+ #define R_LINES_REHASH /* */
+ /* #define R_LINES_OFTEN  /* */
+ #endif
+ 
  /* #define CMDLINE_CONFIG /* allow conf file to be specified on command line */
  
  /*
***************
*** 182,188 ****
   * (PINGFREQUENCY * 2) seconds, then the connection will be closed.
   */
  
! #define PINGFREQUENCY    90	/* Recommended value: 120 */
  
  
  /*
--- 210,216 ----
   * (PINGFREQUENCY * 2) seconds, then the connection will be closed.
   */
  
! #define PINGFREQUENCY    90	/* Recommended value: 90 */
  
  
  /*
diff -rc irc2.5.1.bu.08/include/msg.h irc2.5.1.bu.09/include/msg.h
*** irc2.5.1.bu.08/include/msg.h	Mon Oct 22 11:32:34 1990
--- irc2.5.1.bu.09/include/msg.h	Fri Oct 26 12:18:31 1990
***************
*** 18,23 ****
--- 18,28 ----
   *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ /*
+  * --Hoppie -- 12 Oct 1990
+  * Fixed MSG_LIST to allow another parameter
+  */
+ 
  #define MSG_TEXT     "MSG"
  #define MSG_PRIVATE  "PRIVMSG"
  #define MSG_WHO      "WHO"
diff -rc irc2.5.1.bu.08/include/patchlevel.h irc2.5.1.bu.09/include/patchlevel.h
*** irc2.5.1.bu.08/include/patchlevel.h	Mon Oct 22 11:32:35 1990
--- irc2.5.1.bu.09/include/patchlevel.h	Mon Nov  5 21:20:55 1990
***************
*** 18,21 ****
   */
  
  /* $Header: patchlevel.h,v 2.4 90/05/02 00:24:15 casie Exp $ */
! #define PATCHLEVEL "2.5.1.bu.08"
--- 18,21 ----
   */
  
  /* $Header: patchlevel.h,v 2.4 90/05/02 00:24:15 casie Exp $ */
! #define PATCHLEVEL "2.5.1.bu.09"
diff -rc irc2.5.1.bu.08/include/struct.h irc2.5.1.bu.09/include/struct.h
*** irc2.5.1.bu.08/include/struct.h	Mon Oct 22 11:32:35 1990
--- irc2.5.1.bu.09/include/struct.h	Wed Oct 31 14:15:53 1990
***************
*** 18,23 ****
--- 18,31 ----
   *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ /* -- Hoppie -- 30 Oct 1990
+  * Added support for R lines
+  */
+ 
+ /* -- Hoppie -- 12 Oct 1990
+  * Added support for Q lines
+  */
+ 
  /* -- Jto -- 16 Jun 1990
   * String Channel modifications...
   * Gonzo's PRIVMSG enchantments
***************
*** 113,118 ****
--- 121,129 ----
  #define CONF_CONNECT_SERVER   4
  #define CONF_NOCONNECT_SERVER 8
  /* #define CONF_UPHOST           16 /* not used either --msa */
+ #ifdef R_LINES
+ #define CONF_RESTRICT         16 /*Now it is.  -hoppie (We may need more)*/
+ #endif
  #define CONF_OPERATOR         32
  #define CONF_ME               64
  #define CONF_KILL             128
diff -rc irc2.5.1.bu.08/ircd/ChangeLog irc2.5.1.bu.09/ircd/ChangeLog
*** irc2.5.1.bu.08/ircd/ChangeLog	Mon Oct 22 11:32:37 1990
--- irc2.5.1.bu.09/ircd/ChangeLog	Mon Nov  5 20:28:56 1990
***************
*** 1,7 ****
--- 1,54 ----
+ Mon Nov  5 19:32:09 1990  Tom Hopkins  (hoppie at buengf)
+ 
+ 	* s_msg.c
+ 	  changed m_rehash to make a call to TryConnections and
+ 	  check_pings immediately after rehash
+ 	* ircd.c
+ 	  rewrote main loop to make it (hopefully) eat less CPU under bad
+ 	  conditions and not do too much under good ones.  made check_pings
+ 	  and TryConnectctions exportable to help keep behavior consistent.
+ 	  check_pings now returns a nexttime, like TryConnections.
+ 
+ Fri Nov  2 15:43:37 1990  Tom Hopkins  (hoppie at buengf)
+ 
+ 	* channel.c
+ 	  fixed that nagging MODE bug
+ 
+ Wed Oct 31 14:21:04 1990  Tom Hopkins  (hoppie at buengf)
+ 
+ 	* s_conf.c
+ 	  added support for R lines in initconf()
+ 	  added function find_restrict()
+ 	* s_msg.c
+ 	  added support for R lines in m_user, m_rehash
+ 	* ircd.c
+ 	  added support for R lines in check_pings()
+ 
  Sun Oct 21 18:53:02 1990  Christopher Davis  (ckd at bucsd)
  
  	* Makefile
  	  Added IRCDLIBS and IRCDMODE variables
+ 
+ Tue Oct 16 23:25:00 1990  Thomas Hopkins (hoppie@buengf.bu.edu)
+ 	* s_msg.c
+ 	  Bug fix
+ 
+ Fri Oct 12 22:30:35 1990  Thomas Hopkins (hoppie@buengf.bu.edu)
+ 
+ 	* channel.c
+ 	  Made error returns for MODE and KICK consistent with others
+ 	  Fixed KICK to give the right error message at the right time
+ 	* s_conf.c
+ 	  Added support for Q lines in initconf()
+ 	* s_msg.c
+ 	  added stealth's userlog patch and appropriate headers
+ 	  made error returns consistent and corrected a little spelling 
+ 	  added msa's patch to correctly annotate server kills
+ 	  fixed m_list to make LIST work for specific channels
+ 	  fixed m_invite to allow invite to other channels
+ 	  added support for WALLOPS_REMOTES
+ 	  added support for WALLOPS_QUARANTINE
+ 	  added the patch for stats c
  
  Wed Jun 20 11:53:00 1990  Jarkko Oikarinen (jto@tolsun.oulu.fi)
  
diff -rc irc2.5.1.bu.08/ircd/channel.c irc2.5.1.bu.09/ircd/channel.c
*** irc2.5.1.bu.08/ircd/channel.c	Mon Oct 22 11:32:38 1990
--- irc2.5.1.bu.09/ircd/channel.c	Sat Nov  3 00:35:29 1990
***************
*** 18,23 ****
--- 18,32 ----
   *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ /* -- Hoppie 2 Nov 1990
+  * Fixed that nagging MODE bug
+  */
+ 
+ /* -- Hoppie 12 Oct 1990
+  * Made error returns for MODE and KICK consistent with others
+  * Fixed KICK to give the right error message at the right time
+  */
+ 
  /* -- Jto -- 09 Jul 1990
   * Bug fix
   */
***************
*** 125,131 ****
    aChannel *chptr;
  
    CheckRegistered(sptr);
!   /* Now, try to find the channel in question */
    if (parc > 1)
      chptr = find_channel(parv[1], (aChannel *) 0);
    else {
--- 134,140 ----
    aChannel *chptr;
  
    CheckRegistered(sptr);
!  /* Now, try to find the channel in question */
    if (parc > 1)
      chptr = find_channel(parv[1], (aChannel *) 0);
    else {
***************
*** 175,185 ****
  char *modebuf;
  char *parabuf;
  {
  #define MODE_ADD       1
  #define MODE_DEL       2
    char *curr = parv[0];
!   int whatt = MODE_ADD;
!   int nusers, count = 0, i = 0;
    aClient *who;
    Mode *mode = &(chptr->mode);
    if (parc < 1) {
--- 184,197 ----
  char *modebuf;
  char *parabuf;
  {
+ #define LIMIT_UNSET    0
+ #define LIMIT_SET      1
  #define MODE_ADD       1
  #define MODE_DEL       2
    char *curr = parv[0];
!   unsigned char maddflags = '\0', mdelflags = '\0';
!   int whatt = MODE_ADD, limitflag = LIMIT_UNSET;
!   int nusers, count = 0, i = 0, limit = 0;
    aClient *who;
    Mode *mode = &(chptr->mode);
    if (parc < 1) {
***************
*** 190,256 ****
      switch (*curr) {
      case '+':
        whatt = MODE_ADD;
-       modebuf[i++] = '+';
        break;
      case '-':
        whatt = MODE_DEL;
-       modebuf[i++] = '-';
        break;
      case 'p':
        if (whatt == MODE_ADD)
! 	mode->mode |= MODE_PRIVATE;
        if (whatt == MODE_DEL)
! 	mode->mode &= ~MODE_PRIVATE;
!       modebuf[i++] = 'p';
!       count++;
        break;
      case 's':
        if (whatt == MODE_ADD)
! 	mode->mode |= MODE_SECRET;
        if (whatt == MODE_DEL)
! 	mode->mode &= ~MODE_SECRET;
!       modebuf[i++] = 's';
!       count++;
        break;
      case 'm':
        if (whatt == MODE_ADD)
! 	mode->mode |= MODE_MODERATED;
        if (whatt == MODE_DEL)
! 	mode->mode &= ~MODE_MODERATED;
!       modebuf[i++] = 'm';
!       count++;
        break;
      case 'a':
        if (whatt == MODE_ADD)
! 	mode->mode |= MODE_ANONYMOUS;
        if (whatt == MODE_DEL)
! 	mode->mode &= ~MODE_ANONYMOUS;
!       modebuf[i++] = 'a';
!       count++;
        break;
      case 't':
        if (whatt == MODE_ADD)
! 	mode->mode |= MODE_TOPICLIMIT;
        if (whatt == MODE_DEL)
! 	mode->mode &= ~MODE_TOPICLIMIT;
!       modebuf[i++] = 't';
!       count++;
        break;
      case 'i':
        if (whatt == MODE_ADD)
! 	mode->mode |= MODE_INVITEONLY;
        if (whatt == MODE_DEL)
! 	mode->mode &= ~MODE_INVITEONLY;
!       modebuf[i++] = 'i';
!       count++;
        break;
      case 'n':
        if (whatt == MODE_ADD)
! 	mode->mode |= MODE_NOPRIVMSGS;
        if (whatt == MODE_DEL)
! 	mode->mode &= ~MODE_NOPRIVMSGS;
!       modebuf[i++] = 'n';
!       count++;
        break;
      case 'o':
        parc--;
--- 202,294 ----
      switch (*curr) {
      case '+':
        whatt = MODE_ADD;
        break;
      case '-':
        whatt = MODE_DEL;
        break;
      case 'p':
        if (whatt == MODE_ADD)
! 	{
! 	  maddflags |= MODE_PRIVATE; 
! 	  mdelflags &= ~MODE_PRIVATE;
! 	}
        if (whatt == MODE_DEL)
! 	{
! 	  mdelflags |= MODE_PRIVATE; 
! 	  maddflags &= ~MODE_PRIVATE;
! 	} 
        break;
      case 's':
        if (whatt == MODE_ADD)
! 	{
! 	  maddflags |= MODE_SECRET; 
! 	  mdelflags &= ~MODE_SECRET;
! 	}
        if (whatt == MODE_DEL)
! 	{
! 	  mdelflags |= MODE_SECRET; 
! 	  maddflags &= ~MODE_SECRET;
! 	}
        break;
      case 'm':
        if (whatt == MODE_ADD)
! 	{
! 	  maddflags |= MODE_MODERATED; 
! 	  mdelflags &= ~MODE_MODERATED;
! 	}
        if (whatt == MODE_DEL)
! 	{
! 	  mdelflags |= MODE_MODERATED; 
! 	  maddflags &= ~MODE_MODERATED;
! 	}
        break;
      case 'a':
        if (whatt == MODE_ADD)
! 	{
! 	  maddflags |= MODE_ANONYMOUS;
! 	  mdelflags &= ~MODE_ANONYMOUS;
! 	}
        if (whatt == MODE_DEL)
! 	{
! 	  mdelflags |= MODE_ANONYMOUS;
! 	  maddflags &= ~MODE_ANONYMOUS;
! 	}
        break;
      case 't':
        if (whatt == MODE_ADD)
! 	{
! 	  maddflags |= MODE_TOPICLIMIT;
! 	  mdelflags &= ~MODE_TOPICLIMIT;
! 	}
        if (whatt == MODE_DEL)
! 	{
! 	  mdelflags |= MODE_TOPICLIMIT;
! 	  maddflags &= ~MODE_TOPICLIMIT;
! 	}
        break;
      case 'i':
        if (whatt == MODE_ADD)
! 	{
! 	  maddflags |= MODE_INVITEONLY;
! 	  mdelflags &= ~MODE_INVITEONLY;
! 	}
        if (whatt == MODE_DEL)
! 	{
! 	  mdelflags |= MODE_INVITEONLY;
! 	  maddflags &= ~MODE_INVITEONLY;
! 	}
        break;
      case 'n':
        if (whatt == MODE_ADD)
! 	{
! 	  maddflags |= MODE_NOPRIVMSGS;
! 	  mdelflags &= ~MODE_NOPRIVMSGS;
! 	}
        if (whatt == MODE_DEL)
! 	{
! 	  mdelflags |= MODE_NOPRIVMSGS;
! 	  maddflags &= ~MODE_NOPRIVMSGS;
! 	}
        break;
      case 'o':
        parc--;
***************
*** 261,272 ****
  	  if (IsServer(cptr) || ChanSame(cptr, who)) {
  	    if (whatt == MODE_ADD) {
  	      who->status |= STAT_CHANOP;
  	      modebuf[i++] = 'o';
  	      strcat(parabuf, who->name);
  	      strcat(parabuf, " ");
- 	      count++;
  	    } else if (whatt == MODE_DEL) {
  	      who->status &= ~STAT_CHANOP;
  	      modebuf[i++] = 'o';
  	      strcat(parabuf, who->name);
  	      strcat(parabuf, " ");
--- 299,311 ----
  	  if (IsServer(cptr) || ChanSame(cptr, who)) {
  	    if (whatt == MODE_ADD) {
  	      who->status |= STAT_CHANOP;
+ 	      modebuf[i++] = '+';
  	      modebuf[i++] = 'o';
  	      strcat(parabuf, who->name);
  	      strcat(parabuf, " ");
  	    } else if (whatt == MODE_DEL) {
  	      who->status &= ~STAT_CHANOP;
+ 	      modebuf[i++] = '-';
  	      modebuf[i++] = 'o';
  	      strcat(parabuf, who->name);
  	      strcat(parabuf, " ");
***************
*** 291,299 ****
  	  parv++;
  	  nusers = atoi(parv[0]);
  	  if (nusers > 0) {
! 	    modebuf[i++] = 'l';
  	    sprintf(&(parabuf[strlen(parabuf)]), "%d ", nusers);
! 	    mode->limit = nusers;
  	  }
  	  break;
  	}
--- 330,338 ----
  	  parv++;
  	  nusers = atoi(parv[0]);
  	  if (nusers > 0) {
! 	    limitflag = LIMIT_SET;
  	    sprintf(&(parabuf[strlen(parabuf)]), "%d ", nusers);
! 	    limit = nusers;
  	  }
  	  break;
  	}
***************
*** 302,309 ****
  		     "not given...");
        } else
  	if (whatt == MODE_DEL) {
! 	  modebuf[i++] = 'l';
! 	  mode->limit = 0;
  	}
        count++;
        break;
--- 341,348 ----
  		     "not given...");
        } else
  	if (whatt == MODE_DEL) {
! 	  limitflag = LIMIT_SET;
! 	  limit = 0;
  	}
        count++;
        break;
***************
*** 316,321 ****
--- 355,405 ----
      }
      curr++;
    }
+   mode->mode |= maddflags;
+   mode->mode &= ~mdelflags;
+   modebuf[i++] = '+';
+   if (maddflags & MODE_PRIVATE)
+     modebuf[i++] = 'p';
+   if (maddflags & MODE_SECRET)
+     modebuf[i++] = 's';
+   if (maddflags & MODE_ANONYMOUS)
+     modebuf[i++] = 'a';
+   if (maddflags & MODE_MODERATED)
+     modebuf[i++] = 'm';
+   if (maddflags & MODE_TOPICLIMIT)
+     modebuf[i++] = 't';
+   if (maddflags & MODE_INVITEONLY)
+     modebuf[i++] = 'i';
+   if (maddflags & MODE_NOPRIVMSGS)
+     modebuf[i++] = 'n';
+   modebuf[i++] = '-';
+   if (mdelflags & MODE_PRIVATE)
+     modebuf[i++] = 'p';
+   if (mdelflags & MODE_SECRET)
+     modebuf[i++] = 's';
+   if (mdelflags & MODE_ANONYMOUS)
+     modebuf[i++] = 'a';
+   if (mdelflags & MODE_MODERATED)
+     modebuf[i++] = 'm';
+   if (mdelflags & MODE_TOPICLIMIT)
+     modebuf[i++] = 't';
+   if (mdelflags & MODE_INVITEONLY)
+     modebuf[i++] = 'i';
+   if (mdelflags & MODE_NOPRIVMSGS)
+     modebuf[i++] = 'n';
+   if (limitflag && limit >= 0)
+     {
+       if (limit > 0)
+ 	{
+ 	  modebuf[i++] = '+';
+ 	} 
+       else if (limit == 0)
+ 	{
+ 	  modebuf[i++] = '-'; 
+ 	}
+ 	modebuf[i++] = 'l';
+       mode->limit = limit;
+     }
    modebuf[i] = '\0';
  }
  
diff -rc irc2.5.1.bu.08/ircd/ircd.c irc2.5.1.bu.09/ircd/ircd.c
*** irc2.5.1.bu.08/ircd/ircd.c	Mon Oct 22 11:32:38 1990
--- irc2.5.1.bu.09/ircd/ircd.c	Mon Nov  5 20:35:05 1990
***************
*** 18,23 ****
--- 18,34 ----
   *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ /* -- Hoppie -- 5 Nov 1990
+  * rewrote main loop to make it (hopefully) eat less CPU under bad conditions
+  * and not do too much under good ones.
+  * made check_pings and TryConnections exportable to help keep behavior
+  * consistent.  check_pings now returns a nexttime, like TryConnections.
+  */
+ 
+ /* -- Hoppie -- 31 Oct 1990
+  * added support for R lines
+  */
+ 
  /* -- Jto -- 14 Jul 1990
   * Added Wumpus's MAXIMUM_LINKS fix...
   */
***************
*** 108,120 ****
  **	function should be made latest. (No harm done if this
  **	is called earlier or later...)
  */
! static long TryConnections(currenttime)
  long currenttime;
      {
  	aConfItem *aconf;
  	aClient *cptr;
  	int connected = FALSE;
! 	long nexttime = currenttime + CONNECTFREQUENCY;
  	int connections = 0;
  
  #ifdef MAXIMUM_LINKS
--- 119,131 ----
  **	function should be made latest. (No harm done if this
  **	is called earlier or later...)
  */
! long TryConnections(currenttime)
  long currenttime;
      {
  	aConfItem *aconf;
  	aClient *cptr;
  	int connected = FALSE;
! 	long nexttime = currenttime + HANGONRETRYDELAY;
  	int connections = 0;
  
  #ifdef MAXIMUM_LINKS
***************
*** 181,239 ****
  	return nexttime;
      }
  
! static int check_pings()
      {		
! 	register aClient *cptr;
! 	register int flag;
! 	extern int find_kill();
! 	char reply[128];
  
! 	for (cptr = client; cptr; )
  	    {
! 		if (cptr->flags & FLAGS_DEADSOCKET)
  		    {
! 			/*
! 			** Note: No need to notify opers here. It's
! 			** already done when "FLAGS_DEADSOCKET" is set.
! 			*/
! 			ExitClient((aClient *)NULL, cptr);
! 			cptr = client; /* NOTICE THIS! */
! 			continue;
! 		    }
! 
! 
! 		if (!IsMe(cptr) && cptr->fd >= 0 &&
! 		    ((flag = IsPerson(cptr) ? find_kill(cptr->user->host,
! 					cptr->user->username, reply) : 0) > 0
! 		     ||  (lasttime - cptr->lasttime) > PINGFREQUENCY))
! 		  {
! 		    if ((lasttime - cptr->lasttime) > 2 * PINGFREQUENCY ||
! 			flag > 0)
! 		      {
! 			if (IsServer(cptr))
! 			  sendto_ops("No response from %s, closing link",
! 				     GetClientName(cptr,FALSE));
! 			if (flag && IsPerson(cptr))
! 			  sendto_ops("Kill line active for %s, closing link",
! 				     GetClientName(cptr, FALSE));
! 			if (flag && IsPerson(cptr))
! 			  sendto_one(cptr, reply, me.name,
! 				     ERR_YOUREBANNEDCREEP, cptr->name);
! 			ExitClient((aClient *)NULL, cptr);
! 			cptr = client; /* NOTICE THIS! */
! 			continue;
! 		      }
! 		    else if ((cptr->flags & FLAGS_PINGSENT) == 0)
! 		      {
! 			cptr->flags |= FLAGS_PINGSENT;
! 			sendto_one(cptr, "PING %s", me.name);
! 		      }
! 		    if ((flag == -1) && IsPerson(cptr))
  		      sendto_one(cptr, reply, me.name,
! 				 ERR_YOUWILLBEBANNED, cptr->name);
! 		  }
! 		cptr = cptr->next; /* This must be here, see "NOTICE THIS!" */
  	    }
      }
  
  /*
--- 192,275 ----
  	return nexttime;
      }
  
! long check_pings(currenttime)
! long currenttime;
      {		
!       register aClient *cptr;
!       register int flag,rflag;
!       extern int find_kill();
! #if defined(R_LINES) && defined(R_LINES_OFTEN)
!       extern int find_restrict();
! #endif
!       char reply[128];
!       
!       for (cptr = client; cptr; )
! 	{
! 	  if (cptr->flags & FLAGS_DEADSOCKET)
! 	    {
! 	      /*
! 	       ** Note: No need to notify opers here. It's
! 	       ** already done when "FLAGS_DEADSOCKET" is set.
! 	       */
! 	      ExitClient((aClient *)NULL, cptr);
! 	      cptr = client; /* NOTICE THIS! */
! 	      continue;
! 	    }
  
! 	  if (!IsMe(cptr) && cptr->fd >= 0 &&
! 	      ((flag = IsPerson(cptr) ? find_kill(cptr->user->host,
! 						  cptr->user->username, 
! 						  reply) : 0) > 0
! 	       || (lasttime - cptr->lasttime) > PINGFREQUENCY
! #if defined(R_LINES) && defined(R_LINES_OFTEN)
! 	       || (rflag = IsPerson(cptr) ? 
! 		    find_restrict(cptr->user->host,
! 				  cptr->user->username,reply) : 0) > 0
! #endif
! 	       ))
  	    {
! 	      if ((lasttime - cptr->lasttime) > 2 * PINGFREQUENCY ||
! 		  flag > 0 
! #if defined(R_LINES) && defined(R_LINES_OFTEN)
! 		  || rflag > 0
! #endif
! 		  )
! 		{
! 		  if (IsServer(cptr))
! 		    sendto_ops("No response from %s, closing link",
! 			       GetClientName(cptr,FALSE));
! 		  if (flag && IsPerson(cptr))
  		    {
! 		      sendto_ops("Kill line active for %s, closing link",
! 				 GetClientName(cptr, FALSE));
  		      sendto_one(cptr, reply, me.name,
! 				 ERR_YOUREBANNEDCREEP, cptr->name);
! 		    }
! #if defined(R_LINES) && defined(R_LINES_OFTEN)
! 			if (IsPerson(cptr) && rflag)
! 			  {
! 			    sendto_ops("Restricting %s (%s), closing link.",
! 				       GetClientName(cptr,FALSE),reply);
! 			    sendto_one(cptr,"%s %d :*** %s",me.name,
! 				       ERR_YOUREBANNEDCREEP,reply);
! 			  }
! #endif
! 		  ExitClient((aClient *)NULL, cptr);
! 		  cptr = client; /* NOTICE THIS! */
! 		  continue;
! 		}
! 	      else if ((cptr->flags & FLAGS_PINGSENT) == 0)
! 		{
! 		  cptr->flags |= FLAGS_PINGSENT;
! 		  sendto_one(cptr, "PING %s", me.name);
! 		}
! 	      if ((flag == -1) && IsPerson(cptr))
! 		sendto_one(cptr, reply, me.name,
! 			   ERR_YOUWILLBEBANNED, cptr->name);
  	    }
+ 	  cptr = cptr->next; /* This must be here, see "NOTICE THIS!" */
+ 	}
+       return(currenttime + 0.5*PINGFREQUENCY);
      }
  
  /*
***************
*** 261,266 ****
--- 297,303 ----
  	aClient *cptr;
  	aConfItem *aconf;
  	int length;		/* Length of message received from client */
+ 	long nexttry,nextcheck;
  	char buffer[BUFSIZE];
  	myargv = argv;
  	signal(SIGPIPE, SIG_IGN);
***************
*** 344,350 ****
  	  {
  	    debug(DEBUG_FATAL,
  		  "Failed in reading configuration file %s", configfile);
! 	    printf("Couldn't open configurayion file %s\n", configfile);
  	    exit(-1);
  	  }
  	init_sys(); 
--- 381,387 ----
  	  {
  	    debug(DEBUG_FATAL,
  		  "Failed in reading configuration file %s", configfile);
! 	    printf("Couldn't open configuration file %s\n", configfile);
  	    exit(-1);
  	  }
  	init_sys(); 
***************
*** 371,396 ****
  	debug(DEBUG_DEBUG,"Server ready...");
  	for (;;)
  	    {
! 		long delay = TryConnections(getlongtime());
  
- 		delay -= getlongtime();
  		/*
  		** Adjust delay to something reasonable [ad hoc values]
  		** (one might think something more clever here... --msa)
  		*/
! 		if (delay <= 0)
! 			delay = 1;
! 		else if (delay > TIMESEC)
! 			delay = TIMESEC;
  		if ((length = ReadMessage(buffer, BUFSIZE, &cptr, delay)) > 0)
! 		    {
! 			cptr->lasttime = getlongtime();
! 			cptr->flags &= ~FLAGS_PINGSENT;
! 			dopacket(cptr, buffer, length);
! 		    } 
  		
- 		debug(DEBUG_DEBUG,"Got message");
- 		
  		lasttime = getlongtime();
  		/*
  		** ...perhaps should not do these loops every time,
--- 408,438 ----
  	debug(DEBUG_DEBUG,"Server ready...");
  	for (;;)
  	    {
! 		long delay;
! 		if (nexttry < getlongtime())
! 		  nexttry = TryConnections(getlongtime());
  
  		/*
  		** Adjust delay to something reasonable [ad hoc values]
  		** (one might think something more clever here... --msa)
  		*/
! 		/* Okay, here's my try.  delay is adjusted to stop the next 
! 		   time something could happen in either TryConnections or
! 		   check_pings.  -Hoppie
! 		*/
! 
! 		delay = ((nexttry < nextcheck) ? nexttry : nextcheck)
! 		  - getlongtime();
! 		if (delay <= 0)	
! 		  delay = 1;
  		if ((length = ReadMessage(buffer, BUFSIZE, &cptr, delay)) > 0)
! 		  {
! 		    cptr->lasttime = getlongtime();
! 		    cptr->flags &= ~FLAGS_PINGSENT;
! 		    debug(DEBUG_DEBUG,"Got message");
! 		    dopacket(cptr, buffer, length);
! 		  } 
  		
  		lasttime = getlongtime();
  		/*
  		** ...perhaps should not do these loops every time,
***************
*** 400,406 ****
  		** time might be too far away... (similarly with
  		** ping times) --msa
  		*/
! 		check_pings();
  	    }
      }
  
--- 442,472 ----
  		** time might be too far away... (similarly with
  		** ping times) --msa
  		*/
! 		/* A different tack:  Run these here only when there
! 		** is a chance of something normal happening.  
! 		** A few comments:  First, you might notice that nextcheck 
! 		** will not be right the first time through the loop.  
! 		** I figure if it's too small, it's not a problem since
! 		** it will set itself right after one loop.  If it's too
! 		** big, this is also not a problem since all that will 
! 		** happen is a possible delay in checking pings before 
! 		** receiving the first message which shouldn't need to be
! 		** done anyway.
! 		** Second, there will be a problem if conf->hold changes 
! 		** outside of TryConnect.  I found two places where this 
! 		** can happen, in rehash and in ReadMessage.  The rehash
! 		** one is easy to take care of, simply add a call inside 
! 		** of m_rehash to TryConnections (and maybe check_pings,
! 		** I'm not sure.)  The one for ReadMessage is a little 
! 		** more tricky.  I think the best thing is to simply 
! 		** declare that delay should never be more than the 
! 		** value of HANGONGOODLINK.  This won't incur a great deal
! 		** of extra overhead while still keeping things connecting
! 		** as fast as they ought to. --Hoppie
! 		*/
! 		   
! 		if (nextcheck < getlongtime())
! 		  nextcheck = check_pings(getlongtime());
  	    }
      }
  
diff -rc irc2.5.1.bu.08/ircd/s_conf.c irc2.5.1.bu.09/ircd/s_conf.c
*** irc2.5.1.bu.08/ircd/s_conf.c	Mon Oct 22 11:32:39 1990
--- irc2.5.1.bu.09/ircd/s_conf.c	Wed Oct 31 14:51:51 1990
***************
*** 18,23 ****
--- 18,32 ----
   *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ /* -- Hoppie 31 Oct 1990
+  * added support for R lines in initconf()
+  * added function find_restrict()
+  */
+ 
+ /* -- Hoppie 12 Oct 1990
+  * Added support for Q lines in initconf()
+  */
+ 
  /* -- Jto -- 20 Jun 1990
   * Added gruner's overnight fix..
   */
***************
*** 268,273 ****
--- 277,288 ----
  		      case 'q': /* network.  USE WITH CAUTION! */
  			aconf->status = CONF_QUARANTINED_SERVER;
  			break;
+ #ifdef R_LINES
+ 		      case 'R': /* extended K line */
+ 		      case 'r': /* Offers more options of how to restrict */
+ 			aconf->status = CONF_RESTRICT;
+ 			break;
+ #endif
  		    default:
  			debug(DEBUG_ERROR, "Error in config file: %s", line);
  			break;
***************
*** 343,349 ****
--- 358,412 ----
   		return (tmp ? rc : 0);
       }
  
+ #ifdef R_LINES
+ /* find_restrict works against host/name and calls an outside program 
+    to determine whether a client is allowed to connect.  This allows 
+    more freedom to determine who is legal and who isn't, for example
+    machine load considerations.  The outside program is expected to 
+    return a reply line where the first word is either 'Y' or 'N' meaning 
+    "Yes Let them in" or "No don't let them in."  If the first word 
+    begins with neither 'Y' or 'N' the default is to let the person on.
+    It returns a value of 0 if the user is to be let through -Hoppie  */
  
+ int find_restrict(host, name, reply)
+ char *host, *name, *reply;
+     {
+ 	aConfItem *tmp;
+ 	char *cmdline[132],*temprpl[80],rplchar='Y';
+ 	FILE *fp;
+ 	int rc = 0;
+ 
+ 	for (tmp = conf; tmp; tmp = tmp->next)
+ 	  if (tmp->status == CONF_RESTRICT &&
+ 	      (host == NULL || (matches(tmp->host, host) == 0)) &&
+ 	      (name == NULL || matches(tmp->name, name) == 0))
+ 	    {
+ 	      bzero(reply,5);
+ 	      if (BadPtr(tmp->passwd))
+ 		sendto_ops("Program missing on R-line %s/%s, ignoring.",
+ 			   name,host);
+ 	      else
+ 		{
+ 		  sprintf(cmdline,"%s %s %s",tmp->passwd,name,host);
+ 		  if ((fp=popen(cmdline,"r"))==NULL)
+ 		    sendto_ops("Couldn't run '%s' for R-line %s/%s, ignoring.",
+ 			       tmp->passwd,name,host);
+ 		  else
+ 		    while (fscanf(fp,"%[^\n]\n",temprpl)!=EOF)
+ 		      if (strlen(temprpl)+strlen(reply) < 131)
+ 			sprintf(reply,"%s %s",reply,temprpl);
+ 		      else
+ 			sendto_ops("R-line %s/%s: reply too long, truncating",
+ 				   name,host);
+ 		  pclose(fp);
+ 		  sscanf(reply,"%*[ ]%c%*[^ ]%*[ ]%[^\n]",&rplchar,reply);
+ 		}
+ 	      if (rc=(rplchar == 'n' || rplchar == 'N'))
+ 		break;
+ 	    }
+ 	return (rc);
+       }
+ #endif
  
  /*
  ** check against a set of time intervals
diff -rc irc2.5.1.bu.08/ircd/s_msg.c irc2.5.1.bu.09/ircd/s_msg.c
*** irc2.5.1.bu.08/ircd/s_msg.c	Mon Oct 22 11:32:40 1990
--- irc2.5.1.bu.09/ircd/s_msg.c	Mon Nov  5 20:21:40 1990
***************
*** 21,26 ****
--- 21,50 ----
   *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   */
  
+ /* -- Hoppie -- 5 Nov 1990
+  * changed m_rehash to make immediate call to TryConnections 
+  * and check_pings following it.
+  */
+ 
+ /* -- Hoppie -- 31 Oct 1990
+  * added support for R lines in m_user, m_rehash
+  */
+ 
+ /* -- Hoppie -- 12 Oct 1990
+  * Bug fix
+  */
+ 
+ /* -- Hoppie -- 12 Oct 1990
+  * added stealth's userlog patch and appropriate headers
+  * made error returns consistent and corrected a little spelling 
+  * added msa's patch to correctly annotate server kills
+  * fixed m_list to make LIST work for specific channels
+  * fixed m_invite to allow invite to other channels
+  * added support for WALLOPS_REMOTES
+  * added support for WALLOPS_QUARANTINE
+  * added the patch for stats c
+  */
+ 
  /* -- Jto -- 14 Jul 1990
   * channel operator kill bug fixed
   */
***************
*** 124,129 ****
--- 148,154 ----
  extern char *debugmode;
  extern char *configfile;
  extern int maxusersperchannel;
+ extern long check_pings(),TryConnections();
  
  #define BIGBUFFERSIZE 2000
  
***************
*** 1046,1052 ****
  		int rc;
  		char reply[128];
  		extern int find_kill();
! 		
  		if (rc = find_kill(host, username, reply))
  		  {
  		    sendto_one(sptr, reply, me.name,
--- 1071,1080 ----
  		int rc;
  		char reply[128];
  		extern int find_kill();
! #ifdef R_LINES
! 		extern int find_restrict();
! #endif		
! 
  		if (rc = find_kill(host, username, reply))
  		  {
  		    sendto_one(sptr, reply, me.name,
***************
*** 1054,1059 ****
--- 1082,1095 ----
  		    if (rc > 0)
  		      return ExitClient(sptr, sptr);
  		  }
+ #ifdef R_LINES
+ 	        if (find_restrict(host,username,reply))
+ 		  {
+ 		    sendto_one(sptr,"%s %d :*** %s",me.name,
+ 			       ERR_YOUREBANNEDCREEP,reply);
+ 		    return ExitClient(sptr, sptr);
+ 		  }
+ #endif
  	      }
  	    }
  	make_user(sptr);
***************
*** 2770,2776 ****
  	sendto_one(sptr,":%s %d %s :Rehashing %s",
  		   me.name, RPL_REHASHING, sptr->name, configfile);
  	rehash();
!     }
  
  /************************************************************************
   * m_names() - Added by Jto 27 Apr 1989
--- 2806,2834 ----
  	sendto_one(sptr,":%s %d %s :Rehashing %s",
  		   me.name, RPL_REHASHING, sptr->name, configfile);
  	rehash();
! 
! 	check_pings(getlongtime());
! 	TryConnections(getlongtime()); /* to make behavior consistent -Hop */
! #if defined(R_LINES_REHASH) && !defined(R_LINES_OFTEN)
! 	{
! 	  register aClient *cptr;
! 	  extern int find_restrict();
! 	  char reply[128];
! 	  
! 	  for (cptr=client;cptr;cptr=cptr->next)
! 	    
! 	    if (MyConnect(cptr) && !IsMe(cptr) && IsPerson(cptr) &&
! 		find_restrict(cptr->user->host,cptr->user->username,reply))
! 	      {
! 		sendto_ops("Restricting %s (%s), closing link",
! 			   GetClientName(cptr,FALSE),reply);
! 		sendto_one(cptr,"%s %d :*** %s",me.name,
! 			   ERR_YOUREBANNEDCREEP,reply);
! 		return ExitClient((aClient *)NULL, cptr);
! 	      }
! 	}
! #endif
!       }
  
  /************************************************************************
   * m_names() - Added by Jto 27 Apr 1989
