/*
 * IRCII: a new irc client.  I like it.  I hope you will too 
 *
 * Written By Michael Sandrof <ms5n@andrew.cmu.edu> 
 *
 * Copyright(c) 1990 
 *
 * See the COPYRIGHT file, or do a HELP IRCII COPYRIGHT 
 */
#ifdef HPUX
#include <curses.h>
#endif
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <sys/time.h>
#include <signal.h>
#include <pwd.h>
#ifdef ISC22
#include <sys/bsdtypes.h>
#include <unistd.h>
#endif ISC22
#include "config.h"
#include "irc.h"
#include "vars.h"
#include "input.h"
#include "output.h"
#include "term.h"
#include "exec.h"
#include "window.h"
#include "server.h"

#define NULL 0

#define IRCRC_NAME "/.ircrc"

extern char *getenv();

int irc2_6 = 0;			/* set to true to use irc2.6 server */

int irc_port = IRC_PORT,	/* port of ircd */
    send_text_flag = -1;	/* used in the send_text() routine */

char *invite_channel = null(char *),	/* last channel of an INVITE */
     operator = 0,		/* true is user is oper */
     buffer[BUFFER_SIZE + 1],	/* generic, multipurpose buffer */
    *ircrc_file = null(char *),	/* full path .ircrc file */
     my_path[PATH_LEN + 1],	/* path to users home dir */
     nickname[NICKNAME_LEN + 1],/* users nickname */
     old_nickname[NICKNAME_LEN + 1],	/* last nickname used */
     hostname[NAME_LEN + 1],	/* name of current host */
     realname[REALNAME_LEN + 1],/* real name of user */
     username[NAME_LEN + 1],	/* usernameof user */
    *away_message = null(char *),	/* users away message */
     empty_string[] = "",	/* just an empty string */
     use_flow_control = USE_FLOW_CONTROL,	/* true: ^Q/^S used for flow
						 * cntl */
     irc_io_loop,		/* see irc_io() below */
     dumb = 0,			/* if true, IRCII is put in "dumb" mode */
     who_mask = 0,		/* keeps track of which /who switchs are set */
    *who_host = null(char *),	/* extra /who switch info */
    *who_name = null(char *),	/* extra /who switch info */
    *who_server = null(char *),	/* extra /who switch info */
    *who_nick = null(char *),	/* extra /who switch info */
     oper_command = 0;		/* true just after an oper() command is
				 * given.  Used to tell the difference
				 * between an incorrect password generated by
				 * an oper() command and one generated when
				 * connecting to a new server */

static char cntl_c_hit = 0;

char irc_version[] = "2.02";

/*
 * flush_server: eats all output from server, until there is at least a
 * second delay between bits of servers crap... useful to abort a /links. 
 */
void flush_server()
{
    fd_set rd;
    struct timeval timeout;
    char flushing = 1;

    if (server_read == -1)
	return;
    timeout.tv_usec = 0;
    timeout.tv_sec = 1;
    while (flushing) {
	FD_ZERO(&rd);
	FD_SET(server_read, &rd);
	switch (new_select(&rd, null(fd_set *), &timeout)) {
	    case -1:
	    case 0:
		flushing = 0;
		break;
	    default:
		if (FD_ISSET(server_read, &rd)) {
		    /* if (read(server_read, buffer, BUFFER_SIZE) == 0) */
		    if (dgets(buffer, BUFFER_SIZE, server_read) == 0)
			flushing = 0;
		}
		break;
	}
    }
    /* make sure we've read a full line from server */
    FD_ZERO(&rd);
    FD_SET(server_read, &rd);
    if (new_select(&rd, null(fd_set *), &timeout) > 0)
	dgets(buffer, BUFFER_SIZE, server_read);
}

/* irc_exit: cleans up and leaves */
void irc_exit()
{
         close_server();
    logger(0);
    set_history_file(null(char *));
    if (!dumb) {
	term_cr();
	term_clear_to_eol();
	term_reset();
	term_flush();
#ifdef HPUX
	endwin();		/* Added for curses */
	system("tset -Q");
	system("reset");
#endif
    }
    exit(0);
}

/* sigsegv: something to handle segfaults in a nice way */
void coredump(sig, code, scp)
int sig,
    code;
struct sigcontext *scp;
{
    printf("IRCII has been terminated by a SIG%s\n", signals[sig]);
    printf("Please inform BigCheese (ms5n@andrew.cmu.edu) of this\n");
    printf("with as much detail as possible about what you were doing when it happened.\n");
    fflush(stdout);
    irc_exit();
}

/*
 * quit_response: Used by irc_io() when called from irc_quit to see if we got
 * the right response to our question.  If the response was affirmative, the
 * user gets pooted from irc.  Otherwise, life goes on. 
 */
static void quit_response()
{
    char *ptr;
    int len;

    ptr = get_input();
    irc_io_loop = 0;
    if (len = strlen(ptr)) {
	if (strnicmp(ptr, "yes", len) == 0) {
	    send_to_server("QUIT");
	    irc_exit();
	}
    }
}

/* irc_quit: prompts the user if they wish to exit, then does the right thing */
void irc_quit()
{
    if   (irc_io("Do you really want to quit? ", quit_response))
	     return;
}

/*
 * cntl_c: emergency exit.... if somehow everything else freezes up, hitting
 * ^C five times should kill the program. 
 */
void cntl_c()
{
    if   (cntl_c_hit++ >= 4)
	     irc_exit();
}

/*
 * start_process: using the given args list, this execvps the process,
 * setting stdout of the process to IRCII stdin, and stdin of the process to
 * IRCII stdout.  Stderr of both still go to the tty.  This is used by the -e
 * switch of IRCII to allow a automotons to be written to control IRCII 
 */
static void start_process(args)
char **args;
{
    int p1[2],
        p2[2],
        pid;

    if (pipe(p1) || pipe(p2)) {
	fprintf(stderr, "irc: couldn't start new process: %s\n", sys_errlist[errno]);
	_exit(1);
    }
    switch (pid = fork()) {
	case -1:
	    fprintf(stderr, "irc: couldn't start new process: %s\n", sys_errlist[errno]);
	    _exit(1);
	    break;
	case 0:
	    signal(SIGINT, SIG_IGN);
	    dup2(p1[1], 1);
	    dup2(p2[0], 0);
	    close(p1[0]);
	    close(p2[1]);
	    execvp(args[0], args);
	    fprintf(stderr, "irc: error starting process: %s\n", sys_errlist[errno]);
	    _exit(1);
	    break;
	default:
	    printf("%d\n", pid);
	    fflush(stdout);
	    dup2(p1[0], 0);
	    dup2(p2[1], 1);
	    close(p1[1]);
	    close(p2[0]);
	    if (fork())
		_exit(1);
	    break;
    }
}

/* get_arg: used by parse_args() to get an argument after a switch */
static char *get_arg(arg, next_arg, ac)
char *arg;
char *next_arg;
int *ac;
{
    (*ac)++;
    if (*arg)
	return (arg);
    else {
	if (next_arg)
	    return (next_arg);
	else {
	    fprintf(stderr, "irc: missing parameter\n");
	    exit(1);
	}
    }
}

/*
 * parse_args: parse command line arguments for irc, and sets all initial
 * flags, etc. 
 */
static char *parse_args(argv, argc)
char *argv[];
int argc;
{
    char *arg,
        *ptr;
    int ac;
    int add_servers = 0;
    struct passwd *entry;
    char *channel = null(char *);

    *nickname = null(char);
    *realname = null(char);
    *my_path = null(char);
    ac = 1;
    while (arg = argv[ac++]) {
	if (*(arg++) == '-') {
	    while (*arg) {
		switch (*(arg++)) {
		    case 'c':
			malloc_strcpy(&channel, get_arg(arg, argv[ac], &ac));
			break;
		    case 'p':
			irc_port = atoi(get_arg(arg, argv[ac], &ac));
			break;
		    case 'f':
			use_flow_control = 1;
			break;
		    case 'F':
			use_flow_control = 0;
			break;
		    case 'd':
			dumb = 1;
			break;
		    case 'l':
			malloc_strcpy(&ircrc_file, get_arg(arg, argv[ac], &ac));
			break;
		    case 'a':
			add_servers = 1;
			break;
		    case 'e':
			dumb = 1;
			start_process(&(argv[ac]));
			ac = argc;
			break;
		    default:
			fprintf(stderr, "irc: unknown flag: -%c\nUsage:\n irc [-c chan] [-p port] [-d] [-f|-F] [-a] [nick [serverlist]] [-e program args]\n", *(arg - 1));
			exit(1);
		}
	    }
	} else {
	    if (*nickname)
		build_server_list(arg - 1);
	    else
		strncpy(nickname, arg - 1, NAME_LEN);

	}
    }
    if ((ircrc_file == null(char *)) && (ptr = getenv("IRCRC")))
	malloc_strcpy(&ircrc_file, ptr);
    if ((*nickname == null(char)) && (ptr = getenv("IRCNICK")))
	strncpy(nickname, ptr, NICKNAME_LEN);
    if (ptr = getenv("IRCNAME"))
	strncpy(realname, ptr, REALNAME_LEN);
    if (ptr = getenv("IRCSERVER"))
	build_server_list(ptr);
    if ((server_list_size() == 0) || add_servers) {
#ifdef DEFAULT_SERVER_FILE
	if (read_server_file(DEFAULT_SERVER_FILE) || (server_list_size() == 0))
#endif DEFAULT_SERVER_FILE
	    build_server_list(DEFAULT_SERVER);
    }
    if (entry = getpwuid(getuid())) {
	if ((*realname == null(char)) && entry->pw_gecos && *(entry->pw_gecos)) {
#ifdef GECOS_DELIMITER
	    if (ptr = index(entry->pw_gecos, GECOS_DELIMITER))
		*ptr = null(char);
#endif GECOS_DELIMITER
	    strncpy(realname, entry->pw_gecos, REALNAME_LEN);
	}
	if (entry->pw_name && *(entry->pw_name))
	    strncpy(username, entry->pw_name, NAME_LEN);
	strncpy(my_path, entry->pw_dir, PATH_LEN);
	if (ptr = getenv("HOME"))
	    strncpy(my_path, ptr, PATH_LEN);
    } else {
	if (*realname == null(char))
	    strncpy(realname, "Unknown", REALNAME_LEN);
    }
    if (*my_path == null(char)) {
	if (ptr = getenv("HOME"))
	    strncpy(my_path, ptr, PATH_LEN);
	else
	    strncpy(my_path, "/", PATH_LEN);
    }
    /*
     * "I bet you came here to insert an IRCUSER variable, well, I tell you
     * it's bad style! Think again!"   Lynx 
     */

    if (*username == null(char)) {
	if (ptr = getenv("USER"))
	    strncpy(username, ptr, NAME_LEN);
	else
	    strncpy(username, "Unknown", NAME_LEN);
    }
    if (*nickname == null(char))
	strncpy(nickname, username, NICKNAME_LEN);
    if (ircrc_file == null(char *)) {
	ircrc_file = (char *) new_malloc(strlen(my_path) + strlen(IRCRC_NAME) + 1);
	strcpy(ircrc_file, my_path);
	strcat(ircrc_file, IRCRC_NAME);
    }
    return (channel);
}

/*
 * irc_io: the main irc input/output loop.   Handles all io from keyboard,
 * server, exec'd processes, etc.  If a prompt is specified, it is displayed
 * in the input line and cannot be backspaced over, etc. The func is a
 * function which will take the place of the SEND_LINE function (which is
 * what happens when you hit return at the end of a line). This function must
 * decide if it's ok to exit based on anything you really want.  It can then
 * set the global irc_io_loop to false to cause irc_io to exit. 
 */
int irc_io(prompt, func)
char *prompt;
void (*func) ();
{
    static int level = 0;
    fd_set rd;
    char buffer[BUFFER_SIZE + 1];
    struct timeval cursor_timeout,
            clock_timeout,
            right_away,
           *timeptr;
    char just_got_eof = 0;
    int hold_over;

    /* time before cursor jumps from display area to input line */
    cursor_timeout.tv_usec = 0L;
    cursor_timeout.tv_sec = 1L;

    /* time delay for updating of internal clock */
    clock_timeout.tv_usec = 0L;
    clock_timeout.tv_sec = 30L;

    right_away.tv_usec = 0L;
    right_away.tv_sec = 0L;

    if (level++ > 1) {		/* currently only one level of irc_io()
				 * allowed */
	level--;
	irc_io_loop = 1;
	return (1);
    }
    if (!dumb) {
	set_input_prompt(prompt);
	change_send_line(func);
    }
    timeptr = &clock_timeout;
    while (irc_io_loop) {
	FD_ZERO(&rd);
	FD_SET(0, &rd);
	if (server_read != -1)
	    FD_SET(server_read, &rd);
	set_process_bits(&rd);
	if (term_reset_flag) {
	    refresh_screen();
	    term_reset_flag = 0;
	}
	if (hold_over = unhold_windows())
	    timeptr = &right_away;
	switch (new_select(&rd, null(fd_set *), timeptr)) {
	    case -1:
	    case 0:
		if (cntl_c_hit) {
		    edit_char('\003');
		    cntl_c_hit = 0;
		}
		if (!hold_over)
		    cursor_to_input();
		break;
	    default:
		if (term_reset_flag) {
		    refresh_screen();
		    term_reset_flag = 0;
		}
		/*
		 * must check server before stdin, cause this will hang on a
		 * /FLUSH otherwise 
		 */
		if (server_read != -1) {
		    if (FD_ISSET(server_read, &rd)) {
			switch (dgets(buffer, BUFFER_SIZE, server_read)) {
			    case -1:
				close_server();
				break;
			    case 0:
				close_server();
				if (just_got_eof) {
				    put_it("*** Unable to connect to server %s", current_server_name(null(char *)));
				    get_connected(current_server_index() + 1);
				} else {
				    put_it("*** EOF from server, reconnecting.");
				    get_connected(current_server_index());
				}
				just_got_eof = 1;
				break;
			    default:
				just_got_eof = 0;
				parse_server(buffer);
				break;
			}
		    }
		}
		if (FD_ISSET(0, &rd)) {
		    if (dumb) {
			if (dgets(buffer, BUFFER_SIZE, 0)) {
			    *(buffer + strlen(buffer) - 1) = null(char);
			    parse_command(buffer, 1);
			} else {
			    put_it("*** IRCII exiting on EOF from sdtin!");
			    irc_exit();
			}
		    } else {
			if (read(0, buffer, 1))
			    edit_char(*buffer);
			cntl_c_hit = 0;
		    }
		}
		do_processes(&rd);
		break;
	}
	check_process_limits();
	check_wait_status();
	if (cursor_in_display())
	    timeptr = &cursor_timeout;
	else
	    timeptr = &clock_timeout;
	if (update_clock(0)) {
	    if (get_int_var(CLOCK_VAR) || get_int_var(MAIL_VAR)) {
		update_all_status();
		cursor_to_input();
	    }
	    do_notify();
	}
    }
    level--;
    irc_io_loop = 1;
    set_input_prompt(get_string_var(INPUT_PROMPT_VAR));
    change_send_line(NULL);
    update_input(UPDATE_ALL);
    return (0);
}

main(argc, argv)
char *argv[];
int argc;
{
    char *channel;

#ifdef HPUX
    /* Curses code added for HP-UX use */
    initscr();
    noecho();
    cbreak();
#endif
    channel = parse_args(argv, argc);
    if (gethostname(hostname, NAME_LEN)) {
	fprintf(stderr, "irc: couldn't figure out the name of your machine!\n");
	exit(1);
    }
    if (dumb)
	new_window();
    else {
	init_screen();
#ifndef MUNIX
	signal(SIGCONT, term_cont);
#endif
	signal(SIGINT, cntl_c);
	signal(SIGWINCH, refresh_screen);
	signal(SIGSEGV, coredump);
	signal(SIGBUS, coredump);
    }
    current_channel(channel);
    new_free(&channel);
#ifdef HPUX
    system("stty opost");
#endif

    *old_nickname = null(char);
    get_connected(0);
    init_variables();

#ifdef GLOBAL_IRCRC
    /* read global.ircrc */
    if (access(GLOBAL_IRCRC, R_OK) == 0)
	load(empty_string, GLOBAL_IRCRC);
#endif GLOBAL_IRCRC
    /* read the .ircrc file */
    if (access(ircrc_file, R_OK) == 0)
	load(empty_string, ircrc_file);

    if (!dumb) {
	build_status(null(char *));
	update_input(UPDATE_ALL);
    }
#ifdef MOTD
    {
	struct stat motd_stat,
	     my_stat;
	int des;

	if (stat(MOTD, &motd_stat) == 0) {
	    sprintf(buffer, "%s/.ircmotd", my_path);
	    if (stat(buffer, &my_stat)) {
		my_stat.st_atime = 0L;
		my_stat.st_mtime = 0L;
	    }
	    unlink(buffer);
	    if ((des = open(buffer, O_CREAT, S_IREAD | S_IWRITE)) != -1)
		close(des);
	    if (motd_stat.st_mtime > my_stat.st_mtime) {
		/* display the motd */
		put_file(MOTD);
		/* Thanks to Mark Dame <mdame@uceng.ec.edu> for this one */
		if (get_int_var(PAUSE_AFTER_MOTD_VAR)) {
		    pause("********  Press any key to continue  ********");
		    clear_window(null(Window *));
		}
	    }
	}
    }
#endif MOTD
    irc_io_loop = 1;
    irc_io(get_string_var(INPUT_PROMPT_VAR), NULL);
    irc_exit();
}
